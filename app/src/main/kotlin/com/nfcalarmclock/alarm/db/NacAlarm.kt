package com.nfcalarmclock.alarm.db

import android.content.Context
import android.os.Parcel
import android.os.Parcelable
import androidx.room.ColumnInfo
import androidx.room.Entity
import androidx.room.PrimaryKey
import com.nfcalarmclock.shared.NacSharedPreferences
import com.nfcalarmclock.util.NacCalendar
import com.nfcalarmclock.util.NacCalendar.Day
import com.nfcalarmclock.util.daysToValue
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import java.util.Calendar
import java.util.EnumSet
import java.util.Locale

/**
 * Next alarm object.
 *
 * Really just a container for a NacAlarm and Calendar.
 */
class NacNextAlarm(

	/**
	 * Alarm object corresponding to the next alarm that will run.
	 */
	val alarm: NacAlarm,

	/**
	 * Calendar object corresponding to the next date and time the alarm will run.
	 */
	val calendar: Calendar

)

/**
 * Alarm.
 */
@Entity(tableName = "alarm")
class NacAlarm()
	: Comparable<NacAlarm>,
	Parcelable
{

	/**
	 * Unique alarm ID.
	 * <p>
	 * When setting the Id manually, it must be 0 to be autogenerated.
	 */
	@PrimaryKey(autoGenerate = true)
	@ColumnInfo(name = "id")
	var id: Long = 0

	/**
	 * Whether the alarm is currently active or not.
	 */
	@ColumnInfo(name = "is_active", defaultValue = "0")
	var isActive: Boolean = false

	/**
	 * Amount of time, in milliseconds, the alarm has been active for.
	 *
	 * This will typically only change when the alarm is snoozed.
	 */
	@ColumnInfo(name = "time_active", defaultValue = "0")
	var timeActive: Long = 0

	/**
	 * Number of times the alarm has been snoozed.
	 */
	@ColumnInfo(name = "snooze_count", defaultValue = "0")
	var snoozeCount: Int = 0

	/**
	 * Whether the alarm is enabled or not.
	 */
	@ColumnInfo(name = "is_enabled", defaultValue = "0")
	var isEnabled: Boolean = false

	/**
	 * Hour at which to run the alarm.
	 */
	@ColumnInfo(name = "hour", defaultValue = "0")
	var hour: Int = 0

	/**
	 * Minute at which to run the alarm.
	 */
	@ColumnInfo(name = "minute", defaultValue = "0")
	var minute: Int = 0

	/**
	 * Hour at which to run the alarm, when it is snoozed.
	 */
	@ColumnInfo(name = "snooze_hour", defaultValue = "0")
	var snoozeHour: Int = 0

	/**
	 * Minute at which to run the alarm, when it is snoozed
	 */
	@ColumnInfo(name = "snooze_minute", defaultValue = "0")
	var snoozeMinute: Int = 0

	/**
	 * Days on which to run the alarm.
	 */
	@ColumnInfo(name = "days")
	var days: EnumSet<Day> = EnumSet.noneOf(Day::class.java)

	/**
	 * Date on which to run the alarm, in format of YYYY-MM-DD.
	 */
	@ColumnInfo(name = "date", defaultValue = "")
	var date: String = ""

	/**
	 * Whether the alarm should be repeated or not.
	 */
	@ColumnInfo(name = "should_repeat", defaultValue = "0")
	var shouldRepeat: Boolean = false

	/**
	 * Frequency at which to repeat the alarm.
	 */
	@ColumnInfo(name = "repeat_frequency", defaultValue = "1")
	var repeatFrequency: Int = 1

	/**
	 * Units for the frequency at which to repeat the alarm.
	 *
	 * 0 = Seconds
	 * 1 = Minutes
	 * 2 = Hours
	 * 3 = Days
	 * 4 = Weeks
	 * 5 = Months
	 * 6 = Years
	 */
	@ColumnInfo(name = "repeat_frequency_units", defaultValue = "4")
	var repeatFrequencyUnits: Int = 4

	/**
	 * Units for the frequency at which to repeat the alarm.
	 *
	 * 0 = Seconds
	 * 1 = Minutes
	 * 2 = Hours
	 * 3 = Days
	 * 4 = Weeks
	 * 5 = Months
	 * 6 = Years
	 */
	@ColumnInfo(name = "repeat_frequency_days_to_run_before_starting", defaultValue = "127")
	var repeatFrequencyDaysToRunBeforeStarting: EnumSet<Day> = Day.WEEK

	/**
	 * Whether the alarm should vibrate the phone or not.
	 */
	@ColumnInfo(name = "should_vibrate", defaultValue = "0")
	var shouldVibrate: Boolean = false

	/**
	 * Duration to vibrate the device for.
	 */
	@ColumnInfo(name = "vibrate_duration", defaultValue = "500")
	var vibrateDuration: Long = 500

	/**
	 * Amount of time to wait in between vibrations.
	 */
	@ColumnInfo(name = "vibrate_wait_time", defaultValue = "1000")
	var vibrateWaitTime: Long = 1000

	/**
	 * Whether to vibrate using a pattern or not.
	 */
	@ColumnInfo(name = "should_vibrate_pattern", defaultValue = "0")
	var shouldVibratePattern: Boolean = false

	/**
	 * Number of times to repeat the vibration.
	 */
	@ColumnInfo(name = "vibrate_repeat_pattern", defaultValue = "3")
	var vibrateRepeatPattern: Int = 3

	/**
	 * Amount of time to wait after the vibration has been repeated the set number of
	 * times.
	 */
	@ColumnInfo(name = "vibrate_wait_time_after_pattern", defaultValue = "3000")
	var vibrateWaitTimeAfterPattern: Long = 3000

	/**
	 * Whether the alarm should use NFC or not.
	 */
	@ColumnInfo(name = "should_use_nfc", defaultValue = "0")
	var shouldUseNfc: Boolean = false

	/**
	 * ID of the NFC tag that needs to be used to dismiss the alarm.
	 */
	@ColumnInfo(name = "nfc_tag_id", defaultValue = "")
	var nfcTagId: String = ""

	/**
	 * Order in which to dismiss NFC tags when multiple are selected.
	 */
	@ColumnInfo(name = "nfc_tag_dismiss_order", defaultValue = "0")
	var nfcTagDismissOrder: Int = 0

	/**
	 * Whether the alarm should use the flashlight or not.
	 */
	@ColumnInfo(name = "should_use_flashlight", defaultValue = "0")
	var shouldUseFlashlight: Boolean = false

	/**
	 * Strength level of the flashlight. Only available on API >= 33.
	 */
	@ColumnInfo(name = "flashlight_strength_level", defaultValue = "0")
	var flashlightStrengthLevel: Int = 0

	/**
	 * Amount of time, in seconds, to wait before gradually increasing the flashlight
	 * strength level another step.
	 */
	@ColumnInfo(name = "gradually_increase_flashlight_strength_level_wait_time", defaultValue = "5")
	var graduallyIncreaseFlashlightStrengthLevelWaitTime: Int = 5

	/**
	 * Whether the flashlight should be blinked or not.
	 */
	@ColumnInfo(name = "should_blink_flashlight", defaultValue = "0")
	var shouldBlinkFlashlight: Boolean = false

	/**
	 * Number of seconds to turn on the flashlight.
	 */
	@ColumnInfo(name = "flashlight_on_duration", defaultValue = "1.0")
	var flashlightOnDuration: String = "1.0"

	/**
	 * Number of seconds to turn off the flashlight.
	 */
	@ColumnInfo(name = "flashlight_off_duration", defaultValue = "1.0")
	var flashlightOffDuration: String = "1.0"

	/**
	 * Path to the media that will play when the alarm is run.
	 */
	@ColumnInfo(name = "media_path", defaultValue = "")
	var mediaPath: String = ""

	/**
	 * Artist of the media that will play when the alarm is run.
	 */
	@ColumnInfo(name = "media_artist", defaultValue = "")
	var mediaArtist: String = ""

	/**
	 * Title of the media that will play when the alarm is run.
	 */
	@ColumnInfo(name = "media_title", defaultValue = "")
	var mediaTitle: String = ""

	/**
	 * Type of media.
	 */
	@ColumnInfo(name = "media_type", defaultValue = "0")
	var mediaType: Int = 0

	/**
	 * Local path, internal to the app, to the media that will play when the alarm is run.
	 *
	 * This will only be used if an alarm goes off in direct boot mode.
	 */
	@ColumnInfo(name = "local_media_path", defaultValue = "")
	var localMediaPath: String = ""

	/**
	 * Whether to shuffle the media.
	 *
	 * Note: This is only applicable if playing a directory, otherwise it will
	 *       be ignored.
	 */
	@ColumnInfo(name = "should_shuffle_media", defaultValue = "0")
	var shouldShuffleMedia: Boolean = false

	/**
	 * Whether to recursively play the media in a directory.
	 *
	 * Note: This is only applicable if playing a directory, otherwise it will
	 *       be ignored.
	 */
	@ColumnInfo(name = "should_recursively_play_media", defaultValue = "0")
	var shouldRecursivelyPlayMedia: Boolean = false

	/**
	 * Volume level to set when the alarm is run.
	 */
	@ColumnInfo(name = "volume", defaultValue = "0")
	var volume: Int = 0

	/**
	 * Audio source to use for the media that will play when the alarm is run.
	 */
	@ColumnInfo(name = "audio_source", defaultValue = "")
	var audioSource: String = ""

	/**
	 * Name of the alarm.
	 */
	@ColumnInfo(name = "name", defaultValue = "")
	var name: String = ""

	/**
	 * Whether to say the current time via text-to-speech when the alarm goes off.
	 */
	@ColumnInfo(name = "should_say_current_time", defaultValue = "0")
	var shouldSayCurrentTime: Boolean = false

	/**
	 * Whether to say the alarm name via text-to-speech when the alarm goes off.
	 */
	@ColumnInfo(name = "should_say_alarm_name", defaultValue = "0")
	var shouldSayAlarmName: Boolean = false

	/**
	 * Frequency at which to play text-to-speech, in units of minutes.
	 */
	@ColumnInfo(name = "tts_frequency", defaultValue = "0")
	var ttsFrequency: Int = 0

	/**
	 * Speech rate to use for text-to-speech.
	 */
	@ColumnInfo(name = "tts_speech_rate", defaultValue = "0.7")
	var ttsSpeechRate : Float = 0.7f

	/**
	 * Name of the voice to use for text-to-speech.
	 */
	@ColumnInfo(name = "tts_voice", defaultValue = "")
	var ttsVoice: String = ""

	/**
	 * Whether to gradually increase the volume or not, when an alarm is active.
	 */
	@ColumnInfo(name = "should_gradually_increase_volume", defaultValue = "0")
	var shouldGraduallyIncreaseVolume: Boolean = false

	/**
	 * Amount of time, in seconds, to wait before gradually increasing the
	 * volume another step.
	 */
	@ColumnInfo(name = "gradually_increase_volume_wait_time", defaultValue = "5")
	var graduallyIncreaseVolumeWaitTime: Int = 5

	/**
	 * Whether to restrict changing the volume or not, when an alarm is active.
	 */
	@ColumnInfo(name = "should_restrict_volume", defaultValue = "0")
	var shouldRestrictVolume: Boolean = false

	/**
	 * Whether to auto dismiss or not.
	 */
	@ColumnInfo(name = "should_auto_dismiss", defaultValue = "1")
	var shouldAutoDismiss: Boolean = true

	/**
	 * Time in which to auto dismiss the alarm (seconds).
	 */
	@ColumnInfo(name = "auto_dismiss_time", defaultValue = "900")
	var autoDismissTime: Int = 900

	/**
	 * Whether the alarm can be dismissed early or not.
	 */
	@ColumnInfo(name = "should_dismiss_early", defaultValue = "0")
	var canDismissEarly: Boolean = false

	/**
	 * Whether to show a notification for dismiss early or not.
	 */
	@ColumnInfo(name = "should_show_dismiss_early_notification", defaultValue = "0")
	var shouldShowDismissEarlyNotification: Boolean = false

	/**
	 * Amount of time to allow a user to dismiss early by (minutes).
	 */
	@ColumnInfo(name = "dismiss_early_time", defaultValue = "30")
	var dismissEarlyTime: Int = 30

	/**
	 * Time of alarm that would have been next but was dismissed early.
	 */
	@ColumnInfo(name = "time_of_dismiss_early_alarm", defaultValue = "0")
	var timeOfDismissEarlyAlarm: Long = 0

	/**
	 * Whether to auto snooze or not.
	 */
	@ColumnInfo(name = "should_auto_snooze", defaultValue = "0")
	var shouldAutoSnooze: Boolean = false

	/**
	 * Time in which to auto snooze the alarm (seconds).
	 */
	@ColumnInfo(name = "auto_snooze_time", defaultValue = "300")
	var autoSnoozeTime: Int = 300

	/**
	 * Max number of snoozes.
	 */
	@ColumnInfo(name = "max_snooze", defaultValue = "-1")
	var maxSnooze: Int = -1

	/**
	 * Snooze duration (seconds).
	 */
	@ColumnInfo(name = "snooze_duration", defaultValue = "300")
	var snoozeDuration: Int = 300

	/**
	 * Whether snoozing is easy or not.
	 *
	 * TODO: Can I change a column name?
	 */
	@ColumnInfo(name = "should_use_easy_snooze", defaultValue = "0")
	var shouldEasySnooze: Boolean = false

	/**
	 * Whether snoozing with a volume button is allowed or not.
	 */
	@ColumnInfo(name = "should_volume_snooze", defaultValue = "0")
	var shouldVolumeSnooze: Boolean = false

	/**
	 * Whether to show a reminder or not.
	 */
	@ColumnInfo(name = "should_show_reminder", defaultValue = "0")
	var shouldShowReminder: Boolean = false

	/**
	 * The time to start showing a reminder (minutes).
	 */
	@ColumnInfo(name = "time_to_show_reminder", defaultValue = "5")
	var timeToShowReminder: Int = 5

	/**
	 * Frequency at which to show the reminder, in units of minutes.
	 */
	@ColumnInfo(name = "reminder_frequency", defaultValue = "0")
	var reminderFrequency: Int = 0

	/**
	 * Whether to use text-to-speech for the reminder.
	 */
	@ColumnInfo(name = "should_use_tts_for_reminder", defaultValue = "0")
	var shouldUseTtsForReminder: Boolean = false

	/**
	 * Whether to skip the next alarm or not.
	 */
	@ColumnInfo(name = "should_skip_next_alarm", defaultValue = "0")
	var shouldSkipNextAlarm: Boolean = false

	/**
	 * Whether to delete the alarm after it is dismissed or not.
	 */
	@ColumnInfo(name = "should_delete_alarm_after_dismissed", defaultValue = "0")
	var shouldDeleteAlarmAfterDismissed: Boolean = false

	/**
	 * Check if the alarm has a sound that will be played when it goes off.
	 */
	val hasMedia: Boolean
		get() = mediaPath.isNotEmpty()

	/**
	 * Check if the alarm can be snoozed.
	 *
	 * @return True if the alarm can be snoozed, and False otherwise.
	 */
	val canSnooze: Boolean
		get() = (snoozeCount < maxSnooze) || (maxSnooze < 0)

	/**
	 * Check if the alarm is snoozed.
	 */
	val isSnoozed: Boolean
		get() = snoozeCount > 0

	/**
	 * Check if the alarm is being used, by being active or snoozed.
	 */
	val isInUse: Boolean
		get() = isActive || isSnoozed

	/**
	 * Check if the next alarm will be skipped, and there is only one day that the alarm,
	 * will run on is being used, and repeat is disabled.
	 *
	 * This is a unique case where the next alarm is effectively the final alarm, so
	 * there are basically no alarms after this.
	 */
	val isNextSkippedAndFinal: Boolean
		get() = shouldSkipNextAlarm && (days.size <= 1) && !shouldRepeat

	/**
	 * The normalized alarm name (with newlines replaced with spaces).
	 */
	val nameNormalized: String
		get()
		{
			return if (name.isNotEmpty())
			{
				name.replace("\n", " ")
			}
			else
			{
				name
			}
		}

	/**
	 * ID of the NFC tag that needs to be used to dismiss the alarm.
	 */
	val nfcTagIdList: List<String>
		get()
		{
			// Create the regex
			val regex = Regex(" \\|\\| ")

			return if (nfcTagId.isEmpty())
			{
				// No NFC ID
				emptyList()
			}
			else
			{
				// Try to split the NFC IDs
				nfcTagId.split(regex)
			}
		}

	/**
	 * Check if should use TTS or not.
	 */
	val shouldUseTts: Boolean
		get() = shouldSayCurrentTime || shouldSayAlarmName

	/**
	 * Populate values with input parcel.
	 */
	private constructor(input: Parcel) : this()
	{
		// ID
		id = input.readLong()

		// Active alarm flags
		isActive = input.readInt() != 0
		timeActive = input.readLong()
		snoozeCount = input.readInt()

		// Normal stuff
		isEnabled = input.readInt() != 0
		hour = input.readInt()
		minute = input.readInt()
		setDays(input.readInt())
		date = input.readString() ?: ""

		// Repeat
		shouldRepeat = input.readInt() != 0
		repeatFrequency = input.readInt()
		repeatFrequencyUnits = input.readInt()
		repeatFrequencyDaysToRunBeforeStarting = Day.valueToDays(input.readInt())

		// Vibrate
		shouldVibrate = input.readInt() != 0
		vibrateDuration = input.readLong()
		vibrateWaitTime = input.readLong()
		shouldVibratePattern = input.readInt() != 0
		vibrateRepeatPattern= input.readInt()
		vibrateWaitTimeAfterPattern= input.readLong()

		// NFC
		shouldUseNfc = input.readInt() != 0
		nfcTagId = input.readString() ?: ""
		nfcTagDismissOrder = input.readInt()

		// Flashlight
		shouldUseFlashlight = input.readInt() != 0
		flashlightStrengthLevel = input.readInt()
		graduallyIncreaseFlashlightStrengthLevelWaitTime = input.readInt()
		shouldBlinkFlashlight = input.readInt() != 0
		flashlightOnDuration = input.readString() ?: ""
		flashlightOffDuration = input.readString() ?: ""

		// Media
		mediaPath = input.readString() ?: ""
		mediaArtist = input.readString() ?: ""
		mediaTitle = input.readString() ?: ""
		mediaType = input.readInt()
		localMediaPath = input.readString() ?: ""
		shouldShuffleMedia = input.readInt() != 0
		shouldRecursivelyPlayMedia = input.readInt() != 0

		// Volume and audio source
		volume = input.readInt()
		shouldGraduallyIncreaseVolume = input.readInt() != 0
		graduallyIncreaseVolumeWaitTime = input.readInt()
		shouldRestrictVolume = input.readInt() != 0
		audioSource = input.readString() ?: ""

		// Name
		name = input.readString() ?: ""

		// Text-to-speech
		shouldSayCurrentTime = input.readInt() != 0
		shouldSayAlarmName = input.readInt() != 0
		ttsFrequency = input.readInt()
		ttsSpeechRate = input.readFloat()
		ttsVoice = input.readString() ?: ""

		// Dismiss
		shouldAutoDismiss = input.readInt() != 0
		autoDismissTime = input.readInt()
		canDismissEarly = input.readInt() != 0
		shouldShowDismissEarlyNotification = input.readInt() != 0
		dismissEarlyTime = input.readInt()
		timeOfDismissEarlyAlarm = input.readLong()
		shouldDeleteAlarmAfterDismissed = input.readInt() != 0

		// Snooze
		shouldAutoSnooze = input.readInt() != 0
		autoSnoozeTime = input.readInt()
		maxSnooze = input.readInt()
		snoozeDuration = input.readInt()
		shouldEasySnooze = input.readInt() != 0
		shouldVolumeSnooze = input.readInt() != 0

		// Reminder
		shouldShowReminder = input.readInt() != 0
		timeToShowReminder = input.readInt()
		reminderFrequency = input.readInt()
		shouldUseTtsForReminder = input.readInt() != 0

		// Skip next alarm
		shouldSkipNextAlarm = input.readInt() != 0
	}

	/**
	 * Add to the time, in milliseconds, that the alarm is active.
	 *
	 * @param  time  Time, in milliseconds, to add to the active time.
	 */
	fun addToTimeActive(time: Long)
	{
		timeActive += time
	}

	/**
	 * Compare the next day this alarm will run with another alarm.
	 *
	 * @param  alarm  An alarm.
	 *
	 * @return A negative integer, zero, or a positive integer as this object is
	 * less than, equal to, or greater than the specified object.
	 */
	private fun compareDay(alarm: NacAlarm): Int
	{
		val cal = NacCalendar.getNextAlarmDay(this)
		val otherCal = NacCalendar.getNextAlarmDay(alarm)

		// Both alarms do not have next calendar days so they are technically equal
		return if ((cal == null) && (otherCal == null))
		{
			0
		}
		// This alarm does not have a next calendar day so prioritize the other alarm
		else if (cal == null)
		{
			1
		}
		// The other alarm does not have a next calendar day so prioritize this alarm
		else if (otherCal == null)
		{
			-1
		}
		// Do a normal comparison
		else
		{
			cal.compareTo(otherCal)
		}
	}

	/**
	 * Compare the in use value in this alarm with another alarm.
	 *
	 *
	 * At least one alarm should be in use, otherwise the comparison is
	 * meaningless.
	 *
	 * @param  alarm  An alarm.
	 *
	 * @return A negative integer, zero, or a positive integer as this object is
	 * less than, equal to, or greater than the specified object.
	 */
	private fun compareInUseValue(alarm: NacAlarm): Int
	{
		val value = computeInUseValue()
		val otherValue = alarm.computeInUseValue()

		return if (otherValue < 0)
		{
			-1
		} else if (value < 0)
		{
			1
		} else if (value == otherValue)
		{
			0
		} else
		{
			if (value < otherValue) -1 else 1
		}
	}

	/**
	 * Compare the time of this alarm with another alarm.
	 *
	 * @param  alarm  An alarm.
	 *
	 * @return A negative integer, zero, or a positive integer as this object is
	 * less than, equal to, or greater than the specified object.
	 */
	private fun compareTime(alarm: NacAlarm): Int
	{
		val locale = Locale.getDefault()
		val format = "%1$02d:%2$02d"
		val time = String.format(locale, format, hour, minute)
		val otherTime = String.format(locale, format, alarm.hour, alarm.minute)

		return time.compareTo(otherTime)
	}

	/**
	 * Compare this alarm with another alarm.
	 *
	 * @param  other  An alarm.
	 *
	 * @return A negative integer, zero, or a positive integer as this object is
	 * less than, equal to, or greater than the specified object.
	 */
	override fun compareTo(other: NacAlarm): Int
	{
		return if (this.equals(other))
		{
			0
		} else if (isInUse || other.isInUse)
		{
			val value = compareInUseValue(other)
			if (value == 0)
			{
				compareTime(other)
			} else
			{
				value
			}
		} else if (isEnabled xor other.isEnabled)
		{
			if (isEnabled) -1 else 1
		} else
		{
			compareDay(other)
		}
	}

	/**
	 * Get value corresponding to how in use an alarm is. This is used as a
	 * means to easily compare two alarms that are both in use.
	 *
	 * If an alarm is NOT IN USE, return -1.
	 *
	 * If an alarm is ACTIVE AND NOT SNOOZED, return 0.
	 *
	 * If an alarm is ACTIVE AND SNOOZED, return snooze count.
	 *
	 * If an alarm is NOT ACTIVE AND SNOOZED, return 1000 * snooze count.
	 *
	 * @return A value corresponding to how in use an alarm is.
	 */
	private fun computeInUseValue(): Int
	{
		// Check if alarm is not in use
		if (!isInUse)
		{
			return -1
		}

		// Scale the in use value
		val scale = if (isActive) 1 else 1000

		// Compute value by how many times the alarm has been snoozed
		return scale * snoozeCount
	}

	/**
	 * Create a copy of this alarm.
	 *
	 *
	 * The ID of the new alarm will be set to 0.
	 *
	 * @return A copy of this alarm.
	 */
	fun copy(): NacAlarm
	{
		val alarm = build()

		// ID
		alarm.id = 0

		// Normal stuff
		alarm.isEnabled = isEnabled
		alarm.hour = hour
		alarm.minute = minute
		alarm.days = days
		alarm.date = date
		alarm.shouldRepeat = shouldRepeat
		alarm.repeatFrequency = repeatFrequency
		alarm.repeatFrequencyUnits = repeatFrequencyUnits
		alarm.repeatFrequencyDaysToRunBeforeStarting = repeatFrequencyDaysToRunBeforeStarting
		alarm.shouldVibrate = shouldVibrate
		alarm.vibrateDuration = vibrateDuration
		alarm.vibrateWaitTime = vibrateWaitTime
		alarm.shouldVibratePattern = shouldVibratePattern
		alarm.vibrateRepeatPattern = vibrateRepeatPattern
		alarm.vibrateWaitTimeAfterPattern = vibrateWaitTimeAfterPattern
		alarm.shouldUseNfc = shouldUseNfc
		alarm.nfcTagId = nfcTagId
		alarm.nfcTagDismissOrder = nfcTagDismissOrder
		alarm.shouldUseFlashlight = shouldUseFlashlight
		alarm.flashlightStrengthLevel = flashlightStrengthLevel
		alarm.graduallyIncreaseFlashlightStrengthLevelWaitTime = graduallyIncreaseFlashlightStrengthLevelWaitTime
		alarm.shouldBlinkFlashlight = shouldBlinkFlashlight
		alarm.flashlightOnDuration = flashlightOnDuration
		alarm.flashlightOffDuration = flashlightOffDuration

		// Media
		alarm.mediaPath = mediaPath
		alarm.mediaArtist = mediaArtist
		alarm.mediaTitle = mediaTitle
		alarm.mediaType = mediaType
		alarm.localMediaPath = localMediaPath
		alarm.shouldShuffleMedia = shouldShuffleMedia
		alarm.shouldRecursivelyPlayMedia = shouldRecursivelyPlayMedia

		// Other normal stuff
		alarm.volume = volume
		alarm.audioSource = audioSource
		alarm.name = name

		// Text-to-speech
		alarm.shouldSayCurrentTime = shouldSayCurrentTime
		alarm.shouldSayAlarmName = shouldSayAlarmName
		alarm.ttsFrequency = ttsFrequency
		alarm.ttsSpeechRate = ttsSpeechRate
		alarm.ttsVoice = ttsVoice

		// Volume features
		alarm.shouldGraduallyIncreaseVolume = shouldGraduallyIncreaseVolume
		alarm.graduallyIncreaseVolumeWaitTime = graduallyIncreaseVolumeWaitTime
		alarm.shouldRestrictVolume = shouldRestrictVolume

		// Auto dismiss
		alarm.autoDismissTime = autoDismissTime

		// Dismiss early
		alarm.canDismissEarly = canDismissEarly
		alarm.shouldShowDismissEarlyNotification = shouldShowDismissEarlyNotification
		alarm.dismissEarlyTime = dismissEarlyTime
		alarm.timeOfDismissEarlyAlarm = timeOfDismissEarlyAlarm

		// Snooze
		alarm.autoSnoozeTime = autoSnoozeTime
		alarm.maxSnooze = maxSnooze
		alarm.snoozeDuration = snoozeDuration
		alarm.shouldEasySnooze = shouldEasySnooze
		alarm.shouldVolumeSnooze = shouldVolumeSnooze

		// Reminder
		alarm.shouldShowReminder = shouldShowReminder
		alarm.timeToShowReminder = timeToShowReminder
		alarm.reminderFrequency = reminderFrequency
		alarm.shouldUseTtsForReminder = shouldUseTtsForReminder

		// Skip next alarm
		alarm.shouldSkipNextAlarm = shouldSkipNextAlarm

		// Delete alarm after dismissed
		alarm.shouldDeleteAlarmAfterDismissed = shouldDeleteAlarmAfterDismissed

		return alarm
	}

	/**
	 * Describe contents (required for Parcelable).
	 */
	override fun describeContents(): Int
	{
		return 0
	}

	/**
	 * Dismiss an alarm.
	 *
	 *
	 * This will not update the database, or schedule the next alarm. That
	 * still needs to be done after calling this method.
	 */
	fun dismiss()
	{
		isActive = false
		shouldSkipNextAlarm = false
		timeActive = 0
		snoozeCount = 0
		snoozeHour = -1
		snoozeMinute = -1

		// Check if the alarm should not be repeated
		if (!shouldRepeat)
		{
			// Toggle the alarm
			toggleAlarm()
		}

		// Check if repeat frequency units is in hours
		if (repeatFrequencyUnits == 2)
		{
			// Update the alarm hour
			hour += repeatFrequency
		}
	}

	/**
	 * Dismiss an alarm early.
	 */
	fun dismissEarly()
	{
		// Do not dismiss early if the next alarm will be skipped
		if (shouldSkipNextAlarm)
		{
			return
		}

		// Alarm should be repeated
		if (shouldRepeat)
		{
			val cal = NacCalendar.getNextAlarmDay(this)!!
			val time = cal.timeInMillis

			timeOfDismissEarlyAlarm = time
		}
		// Alarm should only be run once
		else
		{
			toggleAlarm()
		}
	}

	/**
	 * Check if this alarm equals another alarm.
	 *
	 * @param  alarm  An alarm.
	 *
	 * @return True if both alarms are the same, and false otherwise.
	 */
	@Suppress("CovariantEquals")
	fun equals(alarm: NacAlarm?): Boolean
	{
		return (alarm != null)
			&& (this.equalsId(alarm))
			&& (isActive == alarm.isActive)
			&& (timeActive == alarm.timeActive)
			&& (snoozeCount == alarm.snoozeCount)
			&& (isEnabled == alarm.isEnabled)
			&& (hour == alarm.hour)
			&& (minute == alarm.minute)
			&& (days == alarm.days)
			&& (date == alarm.date)
			&& (shouldRepeat == alarm.shouldRepeat)
			&& (repeatFrequency == alarm.repeatFrequency)
			&& (repeatFrequencyUnits == alarm.repeatFrequencyUnits)
			&& (repeatFrequencyDaysToRunBeforeStarting == alarm.repeatFrequencyDaysToRunBeforeStarting)
			&& (shouldVibrate == alarm.shouldVibrate)
			&& (vibrateDuration == alarm.vibrateDuration)
			&& (vibrateWaitTime == alarm.vibrateWaitTime)
			&& (shouldVibratePattern == alarm.shouldVibratePattern)
			&& (vibrateRepeatPattern == alarm.vibrateRepeatPattern)
			&& (vibrateWaitTimeAfterPattern == alarm.vibrateWaitTimeAfterPattern)
			&& (shouldUseNfc == alarm.shouldUseNfc)
			&& (nfcTagId == alarm.nfcTagId)
			&& (nfcTagDismissOrder == alarm.nfcTagDismissOrder)
			&& (shouldUseFlashlight == alarm.shouldUseFlashlight)
			&& (flashlightStrengthLevel == alarm.flashlightStrengthLevel)
			&& (graduallyIncreaseFlashlightStrengthLevelWaitTime == alarm.graduallyIncreaseFlashlightStrengthLevelWaitTime)
			&& (shouldBlinkFlashlight == alarm.shouldBlinkFlashlight)
			&& (flashlightOnDuration == alarm.flashlightOnDuration)
			&& (flashlightOffDuration == alarm.flashlightOffDuration)
			&& (mediaPath == alarm.mediaPath)
			&& (mediaArtist == alarm.mediaArtist)
			&& (mediaTitle == alarm.mediaTitle)
			&& (mediaType == alarm.mediaType)
			&& (localMediaPath == alarm.localMediaPath)
			&& (shouldShuffleMedia == alarm.shouldShuffleMedia)
			&& (shouldRecursivelyPlayMedia == alarm.shouldRecursivelyPlayMedia)
			&& (volume == alarm.volume)
			&& (audioSource == alarm.audioSource)
			&& (name == alarm.name)
			&& (shouldSayCurrentTime == alarm.shouldSayCurrentTime)
			&& (shouldSayAlarmName == alarm.shouldSayAlarmName)
			&& (ttsFrequency == alarm.ttsFrequency)
			&& (ttsSpeechRate == alarm.ttsSpeechRate)
			&& (ttsVoice == alarm.ttsVoice)
			&& (shouldGraduallyIncreaseVolume == alarm.shouldGraduallyIncreaseVolume)
			&& (graduallyIncreaseVolumeWaitTime == alarm.graduallyIncreaseVolumeWaitTime)
			&& (shouldRestrictVolume == alarm.shouldRestrictVolume)
			&& (shouldAutoDismiss == alarm.shouldAutoDismiss)
			&& (autoDismissTime == alarm.autoDismissTime)
			&& (canDismissEarly == alarm.canDismissEarly)
			&& (shouldShowDismissEarlyNotification == alarm.shouldShowDismissEarlyNotification)
			&& (dismissEarlyTime == alarm.dismissEarlyTime)
			&& (timeOfDismissEarlyAlarm == alarm.timeOfDismissEarlyAlarm)
			&& (shouldAutoSnooze == alarm.shouldAutoSnooze)
			&& (autoSnoozeTime == alarm.autoSnoozeTime)
			&& (maxSnooze == alarm.maxSnooze)
			&& (snoozeDuration == alarm.snoozeDuration)
			&& (shouldEasySnooze == alarm.shouldEasySnooze)
			&& (shouldVolumeSnooze == alarm.shouldVolumeSnooze)
			&& (shouldShowReminder == alarm.shouldShowReminder)
			&& (timeToShowReminder == alarm.timeToShowReminder)
			&& (reminderFrequency == alarm.reminderFrequency)
			&& (shouldUseTtsForReminder == alarm.shouldUseTtsForReminder)
			&& (shouldSkipNextAlarm == alarm.shouldSkipNextAlarm)
			&& (shouldDeleteAlarmAfterDismissed == alarm.shouldDeleteAlarmAfterDismissed)
	}

	/**
	 * Check if this alarm has the same ID as another alarm.
	 *
	 * @param  alarm  An alarm.
	 *
	 * @return True if both alarms are the same, and false otherwise.
	 */
	fun equalsId(alarm: NacAlarm): Boolean
	{
		return id == alarm.id
	}

	/**
	 * Fuzzy equals to compare most of the important alarm attributes, but not all
	 * attributes.
	 */
	fun fuzzyEquals(alarm: NacAlarm): Boolean
	{
		return (isEnabled == alarm.isEnabled)
			&& (hour == alarm.hour)
			&& (minute == alarm.minute)
			&& (days == alarm.days)
			&& (date == alarm.date)
			&& (shouldRepeat == alarm.shouldRepeat)
			&& (repeatFrequency == alarm.repeatFrequency)
			&& (repeatFrequencyUnits == alarm.repeatFrequencyUnits)
			&& (repeatFrequencyDaysToRunBeforeStarting == alarm.repeatFrequencyDaysToRunBeforeStarting)
			&& (shouldVibrate == alarm.shouldVibrate)
			&& (vibrateDuration == alarm.vibrateDuration)
			&& (vibrateWaitTime == alarm.vibrateWaitTime)
			&& (shouldVibratePattern == alarm.shouldVibratePattern)
			&& (vibrateRepeatPattern == alarm.vibrateRepeatPattern)
			&& (vibrateWaitTimeAfterPattern == alarm.vibrateWaitTimeAfterPattern)
			&& (shouldUseNfc == alarm.shouldUseNfc)
			&& (nfcTagId == alarm.nfcTagId)
			&& (nfcTagDismissOrder == alarm.nfcTagDismissOrder)
			&& (shouldUseFlashlight == alarm.shouldUseFlashlight)
			&& (flashlightStrengthLevel == alarm.flashlightStrengthLevel)
			&& (graduallyIncreaseFlashlightStrengthLevelWaitTime == alarm.graduallyIncreaseFlashlightStrengthLevelWaitTime)
			&& (shouldBlinkFlashlight == alarm.shouldBlinkFlashlight)
			&& (flashlightOnDuration == alarm.flashlightOnDuration)
			&& (flashlightOffDuration == alarm.flashlightOffDuration)
			&& (mediaPath == alarm.mediaPath)
			&& (volume == alarm.volume)
			&& (audioSource == alarm.audioSource)
			&& (name == alarm.name)
			&& (shouldSayCurrentTime == alarm.shouldSayCurrentTime)
			&& (shouldSayAlarmName == alarm.shouldSayAlarmName)
			&& (ttsFrequency == alarm.ttsFrequency)
			&& (ttsSpeechRate == alarm.ttsSpeechRate)
			&& (ttsVoice == alarm.ttsVoice)
			&& (shouldGraduallyIncreaseVolume == alarm.shouldGraduallyIncreaseVolume)
			&& (shouldRestrictVolume == alarm.shouldRestrictVolume)
			&& (shouldAutoDismiss == alarm.shouldAutoDismiss)
			&& (autoDismissTime == alarm.autoDismissTime)
			&& (canDismissEarly == alarm.canDismissEarly)
			&& (shouldShowDismissEarlyNotification == alarm.shouldShowDismissEarlyNotification)
			&& (dismissEarlyTime == alarm.dismissEarlyTime)
			&& (shouldAutoSnooze == alarm.shouldAutoSnooze)
			&& (autoSnoozeTime == alarm.autoSnoozeTime)
			&& (maxSnooze == alarm.maxSnooze)
			&& (snoozeDuration == alarm.snoozeDuration)
			&& (shouldEasySnooze == alarm.shouldEasySnooze)
			&& (shouldVolumeSnooze == alarm.shouldVolumeSnooze)
			&& (shouldShowReminder == alarm.shouldShowReminder)
			&& (timeToShowReminder == alarm.timeToShowReminder)
			&& (reminderFrequency == alarm.reminderFrequency)
			&& (shouldUseTtsForReminder == alarm.shouldUseTtsForReminder)
			&& (shouldSkipNextAlarm == alarm.shouldSkipNextAlarm)
			&& (shouldDeleteAlarmAfterDismissed == alarm.shouldDeleteAlarmAfterDismissed)
	}

	/**
	 * @return The time string.
	 */
	fun getClockTime(context: Context): String
	{
		return NacCalendar.getClockTime(context, hour, minute)
	}

	/**
	 * Get the meridian (AM or PM).
	 *
	 * @return The meridian (AM or PM).
	 */
	fun getMeridian(context: Context): String
	{
		return NacCalendar.getMeridian(context, hour)
	}

	/**
	 * @see .getNameNormalized
	 */
	fun getNameNormalizedForMessage(max: Int): String
	{
		val name = nameNormalized

		return if (name.length > max)
		{
			"${name.substring(0, max-3)}..."
		}
		else
		{
			name
		}
	}

	/**
	 * Increment the snooze count by 1.
	 */
	private fun incrementSnoozeCount()
	{
		snoozeCount += 1
	}

	/**
	 * Print all values in the alarm object.
	 */
	@Suppress("unused")
	fun print()
	{
		println("Alarm Information")
		println("Id                    : $id")
		println("Is Active             : $isActive")
		println("Time Active           : $timeActive")
		println("Snooze Count          : $snoozeCount")
		println("Is Enabled            : $isEnabled")
		println("Hour                  : $hour")
		println("Minute                : $minute")
		println("Days                  : $days")
		println("Date                  : $date")
		println("Repeat                : $shouldRepeat")
		println("Repeat Freq           : $repeatFrequency")
		println("Repeat Freq Units     : $repeatFrequencyUnits")
		println("Repeat Freq Days 2 Run: $repeatFrequencyDaysToRunBeforeStarting")
		println("Vibrate               : $shouldVibrate")
		println("Vibrate duration      : $vibrateDuration")
		println("Vibrate wait time     : $vibrateWaitTime")
		println("Vibrate pattern       : $shouldVibratePattern")
		println("Vibrate repeat pat.   : $vibrateRepeatPattern")
		println("Vibrate wait after    : $vibrateWaitTimeAfterPattern")
		println("Use NFC               : $shouldUseNfc")
		println("Nfc Tag Id            : $nfcTagId")
		println("Nfc Tag Dismiss Order : $nfcTagDismissOrder")
		println("Use Flashlight        : $shouldUseFlashlight")
		println("Flashlight Strength   : $flashlightStrengthLevel")
		println("Grad Inc Flash        : $graduallyIncreaseFlashlightStrengthLevelWaitTime")
		println("Should Blink Flash    : $shouldBlinkFlashlight")
		println("Flashlight On         : $flashlightOnDuration")
		println("Flashlight Off        : $flashlightOffDuration")
		println("Media Path            : $mediaPath")
		println("Media Artist          : $mediaArtist")
		println("Media Name            : $mediaTitle")
		println("Media Type            : $mediaType")
		println("Local media Path      : $localMediaPath")
		println("Shuffle media         : $shouldShuffleMedia")
		println("Recusively Play       : $shouldRecursivelyPlayMedia")
		println("Volume                : $volume")
		println("Audio Source          : $audioSource")
		println("Name                  : $name")
		println("Tts say time          : $shouldSayCurrentTime")
		println("Tts say name          : $shouldSayAlarmName")
		println("Tts Freq              : $ttsFrequency")
		println("Tts Speech Rate       : $ttsSpeechRate")
		println("Tts Voice             : $ttsVoice")
		println("Grad Inc Vol          : $shouldGraduallyIncreaseVolume")
		println("Grad Inc Vol Wait T   : $graduallyIncreaseVolumeWaitTime")
		println("Restrict Vol          : $shouldRestrictVolume")
		println("Should auto dismiss   : $shouldAutoDismiss")
		println("Auto Dismiss          : $autoDismissTime")
		println("Use Dismiss Early     : $canDismissEarly")
		println("Should Dismiss Early N: $shouldShowDismissEarlyNotification")
		println("Dismiss Early         : $dismissEarlyTime")
		println("Time of Early Alarm   : $timeOfDismissEarlyAlarm")
		println("Should auto snooze    : $shouldAutoSnooze")
		println("Auto Snooze           : $autoSnoozeTime")
		println("Max Snooze            : $maxSnooze")
		println("Snooze Duration       : $snoozeDuration")
		println("Should Easy Snooze    : $shouldEasySnooze")
		println("Should Volume Snooze  : $shouldVolumeSnooze")
		println("Show Reminder         : $shouldShowReminder")
		println("Time to show remind   : $timeToShowReminder")
		println("Reminder freq         : $reminderFrequency")
		println("Use Tts 4 Reminder    : $shouldUseTtsForReminder")
		println("Should skip next      : $shouldSkipNextAlarm")
		println("Should delete after   : $shouldDeleteAlarmAfterDismissed")
	}

	/**
	 * @see .setDays
	 */
	fun setDays(value: Int)
	{
		days = Day.valueToDays(value)
	}

	/**
	 * Snooze the alarm.
	 *
	 * @return Calendar instance of when the snoozed alarm will go off.
	 */
	fun snooze(): Calendar
	{
		// Reset the active flag
		isActive = false

		// Add the snooze duration value to the current time
		val cal = Calendar.getInstance()
		cal.add(Calendar.SECOND, snoozeDuration)

		// Set the snooze hour and minute
		// TODO: Are snooze hour and minute ever used?
		snoozeHour = cal[Calendar.HOUR_OF_DAY]
		snoozeMinute = cal[Calendar.MINUTE]

		// Increment the snooze count. The "isSnoozed" variable checks the
		// snooze count so this basically makes "isSnoozed" true
		incrementSnoozeCount()

		return cal
	}

	/**
	 * Toggle the the current day/enabled attribute of the alarm.
	 *
	 * An alarm can only be toggled if repeat is not enabled.
	 */
	private fun toggleAlarm()
	{
		// Check if the alarm should be repeated
		if (shouldRepeat)
		{
			return
		}

		// Check if there are any days selected
		if (days.isNotEmpty())
		{
			toggleToday()
		}

		// Check if days are NOT selected because if the toggle deselected the last day
		// then the alarm should be disabled.
		//
		// If it did not deselect the last day, then there is no harm in checking again
		// (this use to be the "else" part of the above "if") to disable the alarm
		if (days.isEmpty())
		{
			isEnabled = false
		}
	}

	/**
	 * Toggle a day.
	 */
	fun toggleDay(day: Day)
	{
		// Check if day is contained in the list of alarm days
		if (days.contains(day))
		{
			days.remove(day)
		}
		// Day is not present in alarm days
		else
		{
			days.add(day)
		}
	}

	/**
	 * Toggle repeat.
	 */
	fun toggleRepeat()
	{
		shouldRepeat = !shouldRepeat
	}

	/**
	 * Toggle today.
	 */
	private fun toggleToday()
	{
		// Get today's day
		val day = Day.TODAY

		// Toggle today
		toggleDay(day)
	}

	/**
	 * Toggle use the flashlight.
	 */
	fun toggleUseFlashlight()
	{
		shouldUseFlashlight = !shouldUseFlashlight
	}

	/**
	 * Toggle use NFC.
	 */
	fun toggleUseNfc()
	{
		shouldUseNfc = !shouldUseNfc
	}

	/**
	 * Toggle vibrate.
	 */
	fun toggleVibrate()
	{
		shouldVibrate = !shouldVibrate
	}

	/** Whether or not the alarm will alarm soon.
	 * <p>
	 * "Soon" is determined by the dismiss early time. If it will alarm within
	 * that time, then it is soon.
	 */
	fun willAlarmSoon(): Boolean
	{
		// Alarm is disabled or unable to use dismiss early
		if (!isEnabled || !canDismissEarly || (dismissEarlyTime == 0) || shouldSkipNextAlarm)
		{
			return false
		}

		// Determine the difference in time between the next alarm and today
		val today = Calendar.getInstance()
		val cal = NacCalendar.getNextAlarmDay(this)!!
		val diff = (cal.timeInMillis - today.timeInMillis) / 1000 / 60

		// Compare the two amounts of time
		return (diff < dismissEarlyTime)
	}

	/**
	 * Write data into parcel (required for Parcelable).
	 *
	 * Update this when adding/removing an element.
	 */
	override fun writeToParcel(output: Parcel, flags: Int)
	{
		// ID
		output.writeLong(id)

		// Active alarm flags
		output.writeInt(if (isActive) 1 else 0)
		output.writeLong(timeActive)
		output.writeInt(snoozeCount)

		// Normal stuff
		output.writeInt(if (isEnabled) 1 else 0)
		output.writeInt(hour)
		output.writeInt(minute)
		output.writeInt(days.daysToValue())
		output.writeString(date)

		// Repeat
		output.writeInt(if (shouldRepeat) 1 else 0)
		output.writeInt(repeatFrequency)
		output.writeInt(repeatFrequencyUnits)
		output.writeInt(repeatFrequencyDaysToRunBeforeStarting.daysToValue())

		// Vibrate
		output.writeInt(if (shouldVibrate) 1 else 0)
		output.writeLong(vibrateDuration)
		output.writeLong(vibrateWaitTime)
		output.writeInt(if (shouldVibratePattern) 1 else 0)
		output.writeInt(vibrateRepeatPattern)
		output.writeLong(vibrateWaitTimeAfterPattern)

		// NFC
		output.writeInt(if (shouldUseNfc) 1 else 0)
		output.writeString(nfcTagId)
		output.writeInt(nfcTagDismissOrder)

		// Flashlight
		output.writeInt(if (shouldUseFlashlight) 1 else 0)
		output.writeInt(flashlightStrengthLevel)
		output.writeInt(graduallyIncreaseFlashlightStrengthLevelWaitTime)
		output.writeInt(if (shouldBlinkFlashlight) 1 else 0)
		output.writeString(flashlightOnDuration)
		output.writeString(flashlightOffDuration)

		// Media
		output.writeString(mediaPath)
		output.writeString(mediaArtist)
		output.writeString(mediaTitle)
		output.writeInt(mediaType)
		output.writeString(localMediaPath)
		output.writeInt(if (shouldShuffleMedia) 1 else 0)
		output.writeInt(if (shouldRecursivelyPlayMedia) 1 else 0)

		// Volume and audio source
		output.writeInt(volume)
		output.writeInt(if (shouldGraduallyIncreaseVolume) 1 else 0)
		output.writeInt(graduallyIncreaseVolumeWaitTime)
		output.writeInt(if (shouldRestrictVolume) 1 else 0)
		output.writeString(audioSource)

		// Name
		output.writeString(name)

		// Text-to-speech
		output.writeInt(if (shouldSayCurrentTime) 1 else 0)
		output.writeInt(if (shouldSayAlarmName) 1 else 0)
		output.writeInt(ttsFrequency)
		output.writeFloat(ttsSpeechRate)
		output.writeString(ttsVoice)

		// Dismiss
		output.writeInt(if (shouldAutoDismiss) 1 else 0)
		output.writeInt(autoDismissTime)
		output.writeInt(if (canDismissEarly) 1 else 0)
		output.writeInt(if (shouldShowDismissEarlyNotification) 1 else 0)
		output.writeInt(dismissEarlyTime)
		output.writeLong(timeOfDismissEarlyAlarm)
		output.writeInt(if (shouldDeleteAlarmAfterDismissed) 1 else 0)

		// Snooze
		output.writeInt(if (shouldAutoSnooze) 1 else 0)
		output.writeInt(autoSnoozeTime)
		output.writeInt(maxSnooze)
		output.writeInt(snoozeDuration)
		output.writeInt(if (shouldEasySnooze) 1 else 0)
		output.writeInt(if (shouldVolumeSnooze) 1 else 0)

		// Reminder
		output.writeInt(if (shouldShowReminder) 1 else 0)
		output.writeInt(timeToShowReminder)
		output.writeInt(reminderFrequency)
		output.writeInt(if (shouldUseTtsForReminder) 1 else 0)

		// Skip next alarm
		output.writeInt(if (shouldSkipNextAlarm) 1 else 0)
	}

	companion object
	{

		/**
		 * Generate parcel (required for Parcelable).
		 */
		@Suppress("unused")
		@JvmField
		val CREATOR: Parcelable.Creator<NacAlarm> = object : Parcelable.Creator<NacAlarm>
		{
			override fun createFromParcel(input: Parcel): NacAlarm
			{
				return NacAlarm(input)
			}

			override fun newArray(size: Int): Array<NacAlarm?>
			{
				return arrayOfNulls(size)
			}
		}

		/**
		 * Build an alarm.
		 */
		fun build(shared: NacSharedPreferences? = null): NacAlarm
		{
			// Create an alarm and get calendar instance
			val alarm = NacAlarm()
			val calendar = Calendar.getInstance()

			// Normal stuff
			alarm.isEnabled = true
			alarm.hour = calendar[Calendar.HOUR_OF_DAY]
			alarm.minute = calendar[Calendar.MINUTE]

			// Defaults that probably do not need it because they are already set this way
			alarm.timeOfDismissEarlyAlarm = 0
			alarm.shouldSkipNextAlarm = false

			// Check if shared preferences is set
			if (shared != null)
			{
				// Days
				alarm.days = Day.valueToDays(shared.days)
				alarm.date = shared.date

				// Repeat
				alarm.shouldRepeat = shared.shouldRepeat
				alarm.repeatFrequency = shared.repeatFrequency
				alarm.repeatFrequencyUnits = shared.repeatFrequencyUnits
				alarm.repeatFrequencyDaysToRunBeforeStarting = Day.valueToDays(shared.repeatFrequencyDaysToRunBeforeStarting)

				// Vibrate
				alarm.shouldVibrate = shared.shouldVibrate
				alarm.vibrateDuration = shared.vibrateDuration
				alarm.vibrateWaitTime = shared.vibrateWaitTime
				alarm.shouldVibratePattern = shared.shouldVibratePattern
				alarm.vibrateRepeatPattern = shared.vibrateRepeatPattern
				alarm.vibrateWaitTimeAfterPattern = shared.vibrateWaitTimeAfterPattern

				// NFC
				alarm.shouldUseNfc = shared.shouldUseNfc
				alarm.nfcTagId = shared.nfcTagId
				alarm.nfcTagDismissOrder = shared.nfcTagDismissOrder

				// Flashlight
				alarm.shouldUseFlashlight = shared.shouldUseFlashlight
				alarm.flashlightStrengthLevel = shared.flashlightStrengthLevel
				alarm.graduallyIncreaseFlashlightStrengthLevelWaitTime = shared.graduallyIncreaseFlashlightStrengthLevelWaitTime
				alarm.shouldBlinkFlashlight = shared.shouldBlinkFlashlight
				alarm.flashlightOnDuration = shared.flashlightOnDuration
				alarm.flashlightOffDuration = shared.flashlightOffDuration

				// Media
				alarm.mediaPath = shared.mediaPath
				alarm.mediaArtist = shared.mediaArtist
				alarm.mediaTitle = shared.mediaTitle
				alarm.mediaType = shared.mediaType
				alarm.localMediaPath = shared.localMediaPath
				alarm.shouldShuffleMedia = shared.shouldShuffleMedia
				alarm.shouldRecursivelyPlayMedia = shared.recursivelyPlayMedia

				// Volume and audio source
				alarm.volume = shared.volume
				alarm.shouldGraduallyIncreaseVolume = shared.shouldGraduallyIncreaseVolume
				alarm.graduallyIncreaseVolumeWaitTime = shared.graduallyIncreaseVolumeWaitTime
				alarm.shouldRestrictVolume = shared.shouldRestrictVolume
				alarm.audioSource = shared.audioSource

				// Name
				alarm.name = shared.name

				// Text-to-speech
				alarm.shouldSayCurrentTime = shared.shouldSayCurrentTime
				alarm.shouldSayAlarmName = shared.shouldSayAlarmName
				alarm.ttsFrequency = shared.ttsFrequency
				alarm.ttsSpeechRate = shared.ttsSpeechRate
				alarm.ttsVoice = shared.ttsVoice

				// Auto dismiss
				alarm.shouldAutoDismiss = shared.shouldAutoDismiss
				alarm.autoDismissTime = shared.autoDismissTime
				alarm.canDismissEarly = shared.canDismissEarly
				alarm.shouldShowDismissEarlyNotification = shared.shouldShowDismissEarlyNotification
				alarm.dismissEarlyTime = shared.dismissEarlyTime
				alarm.timeOfDismissEarlyAlarm = 0
				alarm.shouldDeleteAlarmAfterDismissed = shared.shouldDeleteAlarmAfterDismissed

				// Snooze
				alarm.shouldAutoSnooze = shared.shouldAutoSnooze
				alarm.autoSnoozeTime = shared.autoSnoozeTime
				alarm.maxSnooze = shared.maxSnooze
				alarm.snoozeDuration = shared.snoozeDuration
				alarm.shouldEasySnooze = shared.shouldEasySnooze
				alarm.shouldVolumeSnooze = shared.shouldVolumeSnooze

				// Reminder
				alarm.shouldShowReminder = shared.shouldShowReminder
				alarm.timeToShowReminder = shared.timeToShowReminder
				alarm.reminderFrequency = shared.reminderFrequency
				alarm.shouldUseTtsForReminder = shared.shouldUseTtsForReminder
			}

			return alarm
		}

		/**
		 * Calculate the auto dismiss time from a minutes index.
		 */
		fun calcAutoDismissFromMinutesIndex(index: Int): Int
		{
			return index * 60
		}

		/**
		 * Calculate the auto dismiss time from a seconds index.
		 */
		fun calcAutoDismissFromSecondsIndex(index: Int): Int
		{
			return index
		}

		/**
		 * Calculate the auto dismiss index from a value.
		 */
		fun calcAutoDismissIndex(time: Int): Pair<Int, Int>
		{
			// Get the minute and seconds components from the time
			var (minutes, seconds) = calcMinutesAndSecondsFromTime(time)

			// Check if minutes and seconds are both 0. This is no good, and so should
			// default minutes to a better index
			if ((minutes == 0) && (seconds == 0))
			{
				minutes = 15
			}

			// Check if the number is way too big
			if (minutes > 60)
			{
				minutes /= 60
			}

			return Pair(minutes, seconds)
		}

		/**
		 * Calculate the auto snooze time from a minutes index.
		 */
		fun calcAutoSnoozeFromMinutesIndex(index: Int): Int
		{
			return index * 60
		}

		/**
		 * Calculate the auto snooze time from a seconds index.
		 */
		fun calcAutoSnoozeFromSecondsIndex(index: Int): Int
		{
			return index
		}

		/**
		 * Calculate the auto snooze index from a value.
		 */
		fun calcAutoSnoozeIndex(time: Int): Pair<Int, Int>
		{
			// Get the minute and seconds components from the time
			var (minutes, seconds) = calcMinutesAndSecondsFromTime(time)

			// Check if minutes and seconds are both 0. This is no good, and so should
			// default minutes to the 1st index
			if ((minutes == 0) && (seconds == 0))
			{
				minutes = 5
			}

			// Check if the number is way too big
			if (minutes > 30)
			{
				minutes /= 60
			}

			// Calculate the index
			return Pair(minutes, seconds)
		}

		/**
		 * Calculate the dismiss early index from a time.
		 */
		fun calcDismissEarlyIndex(time: Int): Int
		{
			return if (time == 0)
			{
				// Time should never be 0 min, but if it is, use the default of 30 min
				30 / 5 + 3
			}
			else if (time <= 5)
			{
				// 1 to 5 min
				time - 1
			}
			else
			{
				// 10+ min
				time / 5 + 3
			}
		}

		/**
		 * Calculate the dismiss early time from an index.
		 */
		fun calcDismissEarlyTime(index: Int): Int
		{
			return if (index < 5)
			{
				index + 1
			}
			else
			{
				(index - 3) * 5
			}
		}

		/**
		 * Calculate the flashlight on/off duration.
		 */
		fun calcFlashlightOnOffDuration(index: Int): String
		{
			return when (index)
			{
				0    -> "0.5"
				1    -> "1.0"
				2    -> "1.5"
				3    -> "2.0"
				4    -> "2.5"
				5    -> "3.0"
				6    -> "3.5"
				7    -> "4.0"
				8    -> "4.5"
				9    -> "5.0"
				10   -> "5.5"
				11   -> "6.0"
				12   -> "6.5"
				13   -> "7.0"
				14   -> "7.5"
				15   -> "8.0"
				16   -> "8.5"
				17   -> "9.0"
				18   -> "9.5"
				19   -> "10.0"
				else -> "1.0"
			}
		}

		/**
		 * Calculate the flashlight on/off duration index.
		 */
		fun calcFlashlightOnOffDurationIndex(duration: String): Int
		{
			return when (duration)
			{
				"0.5"  -> 0
				"1.0"  -> 1
				"1.5"  -> 2
				"2.0"  -> 3
				"2.5"  -> 4
				"3.0"  -> 5
				"3.5"  -> 6
				"4.0"  -> 7
				"4.5"  -> 8
				"5.0"  -> 9
				"5.5"  -> 10
				"6.0"  -> 11
				"6.5"  -> 12
				"7.0"  -> 13
				"7.5"  -> 14
				"8.0"  -> 15
				"8.5"  -> 16
				"9.0"  -> 17
				"9.5"  -> 18
				"10.0" -> 19
				else   -> 1
			}
		}

		/**
		 * Calculate the gradually increase volume index from a time.
		 */
		fun calcGraduallyIncreaseVolumeIndex(time: Int): Int
		{
			return time - 1
		}

		/**
		 * Calculate the gradually increase volume wait time from an index.
		 */
		fun calcGraduallyIncreaseVolumeWaitTime(index: Int): Int
		{
			return index + 1
		}

		/**
		 * Calculate the max snooze value from an index.
		 */
		fun calcMaxSnooze(index: Int): Int
		{
			return if (index == 11)
			{
				-1
			}
			else
			{
				index
			}
		}

		/**
		 * Calculate the max snooze index from a value.
		 */
		fun calcMaxSnoozeIndex(value: Int): Int
		{
			return if (value == -1)
			{
				11
			}
			else
			{
				value
			}
		}

		/**
		 * Calculate the minutes and seconds components from a time.
		 */
		private fun calcMinutesAndSecondsFromTime(time: Int): Pair<Int, Int>
		{
			val minutes = time / 60
			val seconds = time % 60

			return Pair(minutes, seconds)
		}

		/**
		 * Calculate the repeat frequency units from an index.
		 */
		fun calcRepeatFrequencyUnitsFromIndex(index: Int): Int
		{
			return when (index)
			{
				0 -> 2
				1 -> 3
				2 -> 4
				else -> 4
			}
		}

		/**
		 * Calculate the repeat frequency units index.
		 *
		 * 0 = Seconds
		 * 1 = Minutes
		 * 2 = Hours
		 * 3 = Days
		 * 4 = Weeks
		 * 5 = Months
		 * 6 = Years
		 */
		fun calcRepeatFrequencyUnitsIndex(units: Int): Int
		{
			return when (units)
			{
				2 -> 0
				3 -> 1
				4 -> 2
				else -> 2
			}
		}

		/**
		 * Calculate the repeat frequency from an index.
		 */
		fun calcRepeatFrequencyFromIndex(index: Int): Int
		{
			return index+1
		}

		/**
		 * Calculate the repeat frequency index.
		 */
		fun calcRepeatFrequencyIndex(value: Int): Int
		{
			return value-1
		}

		/**
		 * Calculate the snooze duration from a minutes index.
		 */
		fun calcSnoozeDurationFromMinutesIndex(index: Int): Int
		{
			return index * 60
		}

		/**
		 * Calculate the snooze duration time from a seconds index.
		 */
		fun calcSnoozeDurationFromSecondsIndex(index: Int): Int
		{
			return index
		}

		/**
		 * Calculate the snooze duration index from a value.
		 */
		fun calcSnoozeDurationIndex(value: Int): Pair<Int, Int>
		{
			// Get the minute and seconds components from the time
			var (minutes, seconds) = calcMinutesAndSecondsFromTime(value)

			// Check if minutes and seconds are both 0. This is no good, and so should
			// default minutes to the 1st index
			if ((minutes == 0) && (seconds == 0))
			{
				minutes = 5
			}

			// Check if the number is way too big
			if (minutes > 90)
			{
				minutes /= 60
			}

			// Calculate the index
			return Pair(minutes, seconds)
		}

		/**
		 * Calculate the upcoming reminder time to show index from a time.
		 */
		fun calcUpcomingReminderTimeToShowIndex(time: Int): Int
		{
			return if (time == 0)
			{
				4
			}
			else if (time <= 10)
			{
				time - 1
			}
			else
			{
				time/5 + 7
			}
		}

		/**
		 * Calculate the upcoming reminder time to show from an index.
		 */
		fun calcUpcomingReminderTimeToShow(index: Int): Int
		{
			return if (index < 10)
			{
				index + 1
			}
			else
			{
				(index-7) * 5
			}
		}

	}

}

/**
 * Hilt module to provide an instance of an alarm.
 */
@InstallIn(SingletonComponent::class)
@Module
class NacAlarmModule
{

	/**
	 * Provide an instance of an alarm.
	 */
	@Provides
	fun provideAlarm() : NacAlarm
	{
		return NacAlarm.build()
	}

}
